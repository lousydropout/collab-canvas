# Story 1.3: Obstacle Effects System

## Status
Draft

## Story

**As a** user,
**I want** obstacles to have different effects when hit by the ball,
**so that** the game has variety and strategic depth.

## Acceptance Criteria

1. Obstacles change color to green when hit by ball
2. Random effects are applied: speed boost (1.2x), speed reduction (0.8x), or neutral bounce (1.0x)
3. Visual feedback shows collision effects and color changes with proper animation
4. Game tracks which obstacles have been converted using the game_properties JSONB field
5. Win condition is met when all 30+ obstacles are converted to green
6. Obstacle effects are preserved when returning to canvas mode
7. Effect distribution is configurable (default: 30% speed boost, 30% speed reduce, 40% neutral)
8. Collision events are properly broadcast to other users via real-time system
9. Game session and score data are persisted to database

## Tasks / Subtasks

- [ ] Task 1: Implement Obstacle Effect System (AC: 1, 2, 7)
  - [ ] Create ObstacleEffect interface and effect configuration
  - [ ] Implement random effect assignment on obstacle creation
  - [ ] Add effect distribution configuration (30% boost, 30% reduce, 40% neutral)
  - [ ] Create effect application logic for ball-obstacle collisions

- [ ] Task 2: Implement Visual Feedback System (AC: 3)
  - [ ] Create color change animation for obstacle conversion
  - [ ] Add visual effect indicators for speed boost/reduce
  - [ ] Implement collision effect animations
  - [ ] Add visual feedback for win/lose conditions

- [ ] Task 3: Implement Game State Tracking (AC: 4, 5)
  - [ ] Extend game_properties JSONB field for obstacle tracking
  - [ ] Implement obstacle conversion counting
  - [ ] Add win condition detection (all obstacles green)
  - [ ] Create game state persistence for converted obstacles

- [ ] Task 4: Implement Real-time Event Broadcasting (AC: 8)
  - [ ] Extend real-time events for obstacle_converted events
  - [ ] Broadcast collision effects to other users
  - [ ] Add score_updated events for obstacle conversion
  - [ ] Implement game_ended events for win/lose conditions

- [ ] Task 5: Implement Database Persistence (AC: 6, 9)
  - [ ] Create game session persistence logic
  - [ ] Implement score tracking and storage
  - [ ] Add obstacle state persistence to database
  - [ ] Create game session cleanup on mode switch

- [ ] Task 6: Integration Testing (AC: 1-9)
  - [ ] Test obstacle effect application and visual feedback
  - [ ] Test win/lose condition detection
  - [ ] Test real-time event broadcasting
  - [ ] Test database persistence and state recovery
  - [ ] Test integration with existing canvas functionality

## Dev Notes

### Previous Story Insights:
- **Story 1.1**: Physics engine (Matter.js) is integrated and configured with collision detection
- **Story 1.2**: Game mode with ball, paddle, and basic collision detection is implemented
- **Physics Service**: Available for collision detection and physics body management
- **Canvas Operations**: Existing service for canvas object management and persistence
- **Real-time System**: Existing dual-channel architecture for events

### Data Models:
- **ObstacleEffect Interface**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Complete obstacle effect structure with type, value, and modifiers
- **GameState Interface**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Game state management with obstacle tracking
- **GameRealtimeEvents**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Real-time event interfaces including object_hit, obstacle_converted, score_updated
- **Database Schema**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - game_properties JSONB field, game_sessions table, game_scores table

### API Specifications:
- **CanvasOperations Service**: [Source: lib/canvas/CanvasOperations.ts] - Existing service for canvas object CRUD operations
- **Real-time Events**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - GameRealtimeEvents interface with obstacle_converted, score_updated, game_ended
- **Service Layer Pattern**: [Source: memory-bank/systemPatterns.md] - Follow existing service layer pattern for game operations

### Component Specifications:
- **Canvas Components**: [Source: memory-bank/systemPatterns.md] - Canvas.tsx, CanvasStage.tsx, Rectangle.tsx, Ellipse.tsx
- **React-Konva Integration**: [Source: memory-bank/techContext.md] - Use react-konva components with Konva.js
- **Component Organization**: [Source: memory-bank/techContext.md] - Follow components/canvas/ structure
- **UI Components**: [Source: memory-bank/techContext.md] - Use shadcn/ui components for buttons and controls
- **Animation System**: Extend existing react-konva animation patterns for visual feedback

### File Locations:
- **Game Components**: components/game/ (existing directory)
  - ObstacleEffect.tsx (new)
  - GameEffects.tsx (new)
- **Game Services**: lib/game/ (existing directory)
  - ObstacleEffects.ts (new)
  - GameSession.ts (extend existing)
- **Game Hooks**: hooks/useGame.ts (extend existing)
- **Game Types**: types/game.ts (extend existing)

### Testing Requirements:
- **Test Location**: tests/game/ (existing directory)
- **Test Framework**: Follow existing testing patterns
- **Unit Tests**: Obstacle effect system and visual feedback
- **Integration Tests**: Game state tracking and persistence
- **Real-time Tests**: Event broadcasting functionality
- **Database Tests**: Game session and score persistence

### Technical Constraints:
- **Effect Distribution**: [Source: docs/prd/technical-constraints-and-integration-requirements.md]
  - Default: 30% speed boost, 30% speed reduce, 40% neutral
  - Configurable via game configuration
- **Database Integration**: [Source: docs/prd/technical-constraints-and-integration-requirements.md]
  - Use game_properties JSONB field for obstacle state
  - Maintain existing RLS policies
- **Performance**: [Source: memory-bank/systemPatterns.md] - Maintain existing performance patterns
- **Real-time Sync**: [Source: memory-bank/systemPatterns.md] - Use existing dual-channel architecture
- **TypeScript**: [Source: memory-bank/techContext.md] - Full type safety throughout

### Integration Verification:
- **IV1**: Existing canvas object manipulation (move, resize, delete) works on converted obstacles
- **IV2**: Obstacle color changes are persisted in database and visible to other users
- **IV3**: Game state is properly cleaned up when switching back to canvas mode

### Testing

#### Testing Standards:
- **Test File Location**: tests/game/ directory
- **Test Framework**: Follow existing project testing patterns
- **Unit Testing**: Test obstacle effect system and visual feedback individually
- **Integration Testing**: Test game state tracking and database persistence
- **Real-time Testing**: Test event broadcasting and synchronization
- **Performance Testing**: Validate effect system doesn't impact game performance

#### Specific Testing Requirements:
- Test obstacle effect application and visual feedback
- Test win/lose condition detection
- Test real-time event broadcasting for obstacle conversion
- Test database persistence of game sessions and scores
- Test integration with existing canvas functionality
- Test effect distribution configuration
- Test obstacle state preservation across mode switches

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| Current | 1.0 | Initial story creation from PRD | Product Owner Sarah |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
