# Story 1.2: Game Mode Implementation

## Status
Draft

## Story

**As a** user,
**I want** to start a game mode with ball, paddle, and basic collision detection,
**so that** I can play a Pong-style game using my canvas objects as obstacles.

## Acceptance Criteria

1. "Start Game" button in toolbar switches from canvas mode to game mode
2. Horizontal paddle (8% viewport width × 2% viewport height) appears 5% above bottom edge, controllable with arrow keys at 0.5% viewport width/frame
3. Ball (1% viewport radius) spawns 3% viewport height above paddle and moves with realistic physics at 0.4% viewport width/frame initial speed
4. Ball bounces off paddle, obstacles, and viewport edges with proper physics (restitution: 1.0 for ball, 0.8 for obstacles)
5. Game ends when ball falls through bottom (lose) or all obstacles turn green (win)
6. Viewport is locked during gameplay (no pan/zoom)
7. Game state is properly managed with start/end transitions
8. Real-time events are broadcast for ball movement and paddle position

## Tasks / Subtasks

- [ ] Task 1: Create Game Mode UI Components (AC: 1, 6)
  - [ ] Add "Start Game" button to existing toolbar component
  - [ ] Create game mode toggle state management
  - [ ] Implement viewport locking during gameplay
  - [ ] Add game mode visual indicators

- [ ] Task 2: Implement Game State Management (AC: 7)
  - [ ] Create GameState interface and management service
  - [ ] Implement game mode switching logic
  - [ ] Add game session creation and management
  - [ ] Create game state persistence to database

- [ ] Task 3: Create Paddle Component and Controls (AC: 2)
  - [ ] Create Paddle component using react-konva
  - [ ] Implement paddle positioning (5% above bottom edge)
  - [ ] Add arrow key controls with 0.5% viewport width/frame movement
  - [ ] Create paddle physics body integration

- [ ] Task 4: Implement Ball Component and Physics (AC: 3, 4)
  - [ ] Create Ball component using react-konva
  - [ ] Implement ball spawning (3% viewport height above paddle)
  - [ ] Add ball physics with 0.4% viewport width/frame initial speed
  - [ ] Configure ball physics properties (restitution: 1.0, friction: 0)

- [ ] Task 5: Implement Collision Detection System (AC: 4, 5)
  - [ ] Set up ball-paddle collision detection
  - [ ] Implement ball-obstacle collision detection
  - [ ] Add ball-viewport edge collision detection
  - [ ] Create win/lose condition detection

- [ ] Task 6: Add Real-time Event Broadcasting (AC: 8)
  - [ ] Extend real-time events for game state
  - [ ] Broadcast ball movement events
  - [ ] Broadcast paddle position events
  - [ ] Add game state change events

- [ ] Task 7: Integration Testing (AC: 1-8)
  - [ ] Test game mode switching functionality
  - [ ] Verify paddle controls work correctly
  - [ ] Test ball physics and collision detection
  - [ ] Validate real-time event broadcasting
  - [ ] Test game state transitions

## Dev Notes

### Previous Story Insights:
- **Story 1.1**: Physics engine (Matter.js) is integrated and configured
- **Physics Service**: Available for creating physics bodies and collision detection
- **Canvas Operations**: Existing service for canvas object management
- **Real-time System**: Existing dual-channel architecture for events

### Data Models:
- **GameState Interface**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Complete game state management structure
- **GameRealtimeEvents**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Real-time event interfaces for game mechanics
- **CanvasObject Extension**: [Source: types/canvas.ts] - Existing interface extended with physics body reference
- **Game Sessions**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - Database schema for game_sessions table

### API Specifications:
- **CanvasOperations Service**: [Source: lib/canvas/CanvasOperations.ts] - Existing service for canvas object CRUD operations
- **Real-time Events**: [Source: docs/prd/technical-constraints-and-integration-requirements.md] - GameRealtimeEvents interface with ball_moved, paddle_moved, game_started, game_ended
- **Service Layer Pattern**: [Source: memory-bank/systemPatterns.md] - Follow existing service layer pattern for game operations

### Component Specifications:
- **Canvas Components**: [Source: memory-bank/systemPatterns.md] - Canvas.tsx, CanvasStage.tsx, Rectangle.tsx, Ellipse.tsx
- **React-Konva Integration**: [Source: memory-bank/techContext.md] - Use react-konva components with Konva.js
- **Component Organization**: [Source: memory-bank/techContext.md] - Follow components/canvas/ structure
- **UI Components**: [Source: memory-bank/techContext.md] - Use shadcn/ui components for buttons and controls
- **Viewport-Relative Sizing**: All game elements sized as percentages of viewport dimensions for responsive gameplay

### File Locations:
- **Game Components**: components/game/ (new directory)
  - Paddle.tsx (new)
  - Ball.tsx (new)
  - GameMode.tsx (new)
- **Game Services**: lib/game/ (new directory)
  - GameState.ts (new)
  - GameSession.ts (new)
- **Game Hooks**: hooks/useGame.ts (new)
- **Game Types**: types/game.ts (new)

### Testing Requirements:
- **Test Location**: tests/game/ (new directory)
- **Test Framework**: Follow existing testing patterns
- **Unit Tests**: Game components and services
- **Integration Tests**: Game mode integration with canvas operations
- **Real-time Tests**: Event broadcasting functionality

### Technical Constraints:
- **Physics Configuration**: [Source: docs/prd/technical-constraints-and-integration-requirements.md]
  - Ball: restitution: 1.0, friction: 0, frictionAir: 0.01, density: 0.001
  - Paddle: restitution: 0.8, friction: 0.1, isStatic: false, density: 0.001
- **Viewport-Relative Sizing**: All game elements must scale with viewport dimensions
  - Paddle: 8% viewport width × 2% viewport height
  - Ball: 1% viewport radius
  - Movement speeds: 0.5% viewport width/frame (paddle), 0.4% viewport width/frame (ball)
- **Performance**: [Source: memory-bank/systemPatterns.md] - Maintain existing performance patterns
- **Real-time Sync**: [Source: memory-bank/systemPatterns.md] - Use existing dual-channel architecture
- **TypeScript**: [Source: memory-bank/techContext.md] - Full type safety throughout

### Integration Verification:
- **IV1**: Existing canvas objects remain visible and functional after game ends
- **IV2**: Real-time collaboration features (cursors, presence) work in game mode
- **IV3**: Game mode can be exited and returned to canvas mode seamlessly

### Testing

#### Testing Standards:
- **Test File Location**: tests/game/ directory
- **Test Framework**: Follow existing project testing patterns
- **Unit Testing**: Test game components and services individually
- **Integration Testing**: Test game mode integration with existing canvas operations
- **Real-time Testing**: Test event broadcasting and synchronization
- **Performance Testing**: Validate game performance doesn't impact canvas mode

#### Specific Testing Requirements:
- Test game mode switching functionality
- Test paddle controls and movement (viewport-relative)
- Test ball physics and collision detection (viewport-relative)
- Test win/lose condition detection
- Test real-time event broadcasting
- Test game state persistence
- Test integration with existing canvas functionality
- Test responsive behavior across different viewport sizes

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| Current | 1.0 | Initial story creation from PRD | Product Owner Sarah |
| Current | 1.1 | Updated to use viewport-relative sizing instead of fixed pixels | Product Owner Sarah |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
